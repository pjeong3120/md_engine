from abc import ABC, abstractmethod
import numpy as np
from src.utils import check_pbc, get_distance_matrices_pbc


class Potential(ABC):
    def __init__(self):
        """
        Potential parameterization
        """
        super().__init__()

    @abstractmethod
    def get_energy_force(self, r):
        """
        Forward call of the potential
        """
        N = r.shape[-2]
        d = r.shape[-1]

        system_pe = 0
        per_atom_pe = np.zeros((N,))
        per_atom_force = np.zeros((N, d))
        atom_atom_force = np.zeros((N, N, d))
        return system_pe, per_atom_pe, per_atom_force, atom_atom_force


class LennardJones(Potential):
    def __init__(self, 
                 sigma : float, 
                 epsilon : float,
                 unit_cell : np.ndarray,
                 r_max : float):
        super().__init__()
        self.sigma = sigma
        self.epsilon = epsilon
        self.unit_cell = unit_cell
        self.r_max = r_max
        self.cutoff_energy = 4 * self.epsilon * ((self.sigma / r_max) ** 12 - (self.sigma / r_max) ** 6)
    
    def get_energy_force(self, r):
        """
        Computes the per atom potential energy and force.
        Periodic boundary conditions are applied when computing energies and forces

        Input: 
        - r (np.ndarray): Numpy matrix with shape (N, d) with the positions of each particle
        
        Returns:
        - potential_energy (np.ndarray): Numpy vector with shape (N,) with per-atom potential energy
        - forces (np.ndarray): Numpy matrix with shape (N, d) with per-atom forces
        """

        # Step 1 - Compute distances and directions for closest neighbors according to pbc
        displacement_tensor, distance_matrix = get_distance_matrices_pbc(r, self.unit_cell)

        # Step 2 - Create a mask to ignore self-interaction and r > r_max
        # Note that mask is (N, N)
        mask = np.logical_and(distance_matrix < self.r_max, distance_matrix > 0)

        # Step 3 - potential energy
        potential_energy = np.zeros_like(distance_matrix) # Non-contributing terms
        potential_energy[mask] =  4 * self.epsilon * ((self.sigma / distance_matrix[mask]) ** 12 
                                                      - (self.sigma / distance_matrix[mask]) ** 6) - self.cutoff_energy
        per_atom_pe = potential_energy.sum(axis = 1)
        system_pe = potential_energy.sum() / 2
        #system_pe = np.triu(potential_energy, k=0).sum() # The line above is equivalent to this line
                                                          # We take the upper right triangle because system 
                                                          # energy is equal to the sum over PAIRS, not atoms. 
                                                          # See note below for a deeper explanation

        # Step 4 - forces
        atom_atom_force = np.zeros_like(displacement_tensor) # (N, N, d)
        atom_atom_force[mask] = 24 * self.epsilon * ((
                2 * (self.sigma / distance_matrix[mask]) ** 12 - 
                (self.sigma / distance_matrix[mask]) ** 6
                ) / (distance_matrix[mask] ** 2)
            )[:, np.newaxis] * displacement_tensor[mask]
        per_atom_force = atom_atom_force.sum(axis = 1) # Sum along all atoms j 

        return system_pe, per_atom_pe, per_atom_force, atom_atom_force





"""
NOTE regarding system vs atom potential energy - 

"potential energy" is referred to as "energy" for brevity

When computing system energy, we sum over all atoms and then divide in half. 
The reason for this is important and subtle
When per-atom energy is computed, it is computed as if all other atoms are fixed in position
and the atom of interest is allowed to move freely in the field generated by fixed neighboring atoms.
The force is then computed by taking of the gradient of the atom's position wrt this field. 
Physically, the per-atom energy is equal to the energy it takes to remove a particle from the field. 

This means that the total system energy is equal to the energy of each unique PAIR of atoms, not the sum over all atoms.
In other words, if we sum over all atoms, we've over-counted all U(i, j) as being different from U(j, i). 
Note that U(i, i) is correctly counted exactly once but self interaction energy is zero so we don't need to worry about
counting self interaction energy correctly. 
Thus, we can correct for the overcounting by simply dividing by 2.

In np matrix lingo, the correct system_energy computation is summing over the upper right triangle (including diagonal)
of the potential_energy matrix

In the case where self interaction energy is nonzero, dividing by 2 is no longer sufficient. Instead, we should sum
over the upper right triangle (including diagonal)
"""


